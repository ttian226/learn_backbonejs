### Application view

让我们检查下在视图中的核心应用的逻辑。例如每一个视图都支持在当前的位置进行编辑这种功能，因此包含了一些合理的逻辑。为了帮助组织这种逻辑，我们将使用元素控制模式（element controller pattern）。这种元素控制模式包含了两个视图：一个视图控制todo的集合，而另一个视图处理独立的todo项。

在我们的例子中，一个`AppView`将创建一个新的todos，渲染初始的todo列表。`TodoView`的实例将关联每一个独立的Todo。Todo实例能够处理编辑，更新，和销毁与它关联的todo。

为了保持简短和简单，在向导中我们没有实现应用的所有特性，我们只是覆盖了那些能让你起步的东西，即使这样，在`AppView`中仍然有很多东西，所以我们来分两部分讨论。

```javascript

  // js/views/app.js

  var app = app || {};

  // The Application
  // ---------------

  // Our overall **AppView** is the top-level piece of UI.
  app.AppView = Backbone.View.extend({

    // Instead of generating a new element, bind to the existing skeleton of
    // the App already present in the HTML.
    el: '#todoapp',

    // Our template for the line of statistics at the bottom of the app.
    statsTemplate: _.template( $('#stats-template').html() ),

    // At initialization we bind to the relevant events on the `Todos`
    // collection, when items are added or changed.
    initialize: function() {
      this.allCheckbox = this.$('#toggle-all')[0];
      this.$input = this.$('#new-todo');
      this.$footer = this.$('#footer');
      this.$main = this.$('#main');

      this.listenTo(app.Todos, 'add', this.addOne);
      this.listenTo(app.Todos, 'reset', this.addAll);
    },

    // Add a single todo item to the list by creating a view for it, and
    // appending its element to the `<ul>`.
    addOne: function( todo ) {
      var view = new app.TodoView({ model: todo });
      $('#todo-list').append( view.render().el );
    },

    // Add all items in the **Todos** collection at once.
    addAll: function() {
      this.$('#todo-list').html('');
      app.Todos.each(this.addOne, this);
    }

  });
```

我们AppView的初始版本中呈现了一些明显的特性，包括一个`statsTemplate`，一个`initialize`方法当实例化时被隐式的调用，还有一些视图中特定的方法。

在我们的应用中，`el`属性存储了一个选择符，它指向了ID为`todoapp`的DOM元素。在index.html中`el`引用的是`<section id="todoapp" />`元素。

使用我们的#stats-template，通过underscore中的模板方法`_.template()`来创建一个statsTemplate对象。稍后我们将使用这个模板来渲染视图。

现在我们看一下`initialize`方法。首先，它使用jQuery来缓存元素，它使用本地（Backbone）的属性来调用（相比`this.$el`引用的当前元素的jQuery对象来说，`this.$()`是通过find方法来查找元素）。然后给Todos集合绑定了两个事件：`add`和`reset`。由于我们委托`TodoView`来处理更新和删除，我们这里不用担心。两个逻辑如下：

* 当集合的add事件触发时，`addOne()`方法会被调用，并且被传入了一个新的model。`addOne()`方法创建一个TodoView视图的实例，并渲染，然后把渲染后的元素插入到todo列表中。
* 当集合的reset事件触发时（例如，当Todos由本地存储加载于此同时一次性更新集合）`addAll()`方法被调用，它将遍历当前在集合中所有的todos，并对每一项调用`addOne()`方法。

注意我们能够在`addAll()`方法中使用`this`来引用视图。因为当`addAll()`方法被绑定的时候，listenTo()隐式的设置了回调函数的上下文。

现在我们添加一些更多的逻辑来完成我们的AppView！
